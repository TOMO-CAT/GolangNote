# 数值类型

## 布尔型

`Go`语言中布尔类型不能接受其他类型的赋值，不支持自动或者强制的类型转换。例如：

```go
/* 编译错误 */
var fooBool bool
fooBool = 1         // 编译错误
fooBool = bool(1)   // 编译错误
```

## 整型

`Go`语言整型类型如下：

| 数据类型        | 有/无符号 | 长度（字节） | 值范围                                     |
| --------------- | --------- | ------------ | ------------------------------------------ |
| int             | 有        | 平台相关     | 平台相关                                   |
| int8            | 有        | 1            | -128 ~ 127                                 |
| int16           | 有        | 2            | -32768 ~ 32767                             |
| int32           | 有        | 4            | -2147484648 ~ 2147483647                   |
| int64           | 有        | 8            | -9223372036854775808 ~ 9223372036854775807 |
| uint            | 无        | 平台相关     | 平台相关                                   |
| uint8（即byte） | 无        | 1            | 0 ~ 255                                    |
| uint16          | 无        | 2            | 0 ~ 65535                                  |
| uint32          | 无        | 4            | 0 ~ 4294967295                             |
| uint64          | 无        | 8            | 0 ~ 18446744073709551615                   |
| uintptr         |           | 同指针       | 32位平台下为4字节，64位平台下为8字节       |

#### 1. 整型类型分类

* 前缀是否带`u`：带`u`表示无符号类型，不带`u`表示有符号类型
* 后缀数值：`8`、`16`、`32`和`64`这些后缀表示类型长度是几个`bit`
* `int`和`uint`平台相关：方便跨平台，但是在二进制传输等场景下应该避免使用（使用更加精确的`int32`和`int64`）

#### 2. int和int32/int64是两种不同类型

需要注意在`Go`语言中，`int`和`int32/int64`会被认为是两种不同的类型，编译器并不会帮你做自动类型转换：

```go
/* 编译错误 */
var valueInt32 int32
valueInt := 64                  // value会被编译器自动推断为int类型
valueint32 = valueInt           // 编译错误: 不支持自动类型转换

valueInt32 = int32(valueInt)    // 编译通过: 支持强制类型转换, 需要注意精度损失和值溢出的问题
```

#### 3. 位运算

`Go`语言的大多数位运算符都与`C`语言类似，除了取反在`C`语言中是`~x`，而在`Go`语言中是`^x`。

| 运算   | 含义 | 样例           |
| ------ | ---- | -------------- |
| x << y | 左移 | 124 << 2 = 494 |
| x >> y | 右移 | 124 >> 2 = 31  |
| x ^ y  | 异或 | 124 ^ 2 = 126  |
| x & y  | 与   | 124 & 2 = 0    |
| x \| y | 或   | 124 \| 2 = 126 |
| ^x     | 取反 | ^2 = -3        |

## 浮点型

> `Go`语言中的浮点类型采用`IEEE-754`标准，关于浮点数的底层存储原理详见文章：[浮点数的底层原理和精度损失问题](https://zhuanlan.zhihu.com/p/269619376)

`Go`语言定义了`float32`和`float64`两种精度的浮点数，相当于`C`语言中的`float`和`double`类型。

#### 1. 浮点型字面量自动推导为float64

需要注意的是，浮点型字面量（无类型）赋值给一个变量时会被自动推导为`float64`，比如：

``` go
/* valueFloat会被自动推导为float64 */
valueFloat := 3.14 

var valueFloat32 float32
valueFloat32 = float32(valueFloat)  // 只能使用强制类型转换
```

#### 2. 浮点型比较

由于浮点型不是一种精确（十进制和二进制转换之间存在误差）的表达方式，像整形一样直接使用`==`比较两个浮点数是否相同是行不通的，可以使用用户自定义函数：

```go
import "math"

/* p为用户自定义精度, 比如0.00001 */
func IsFloatEqual(f1, f2, p float64) bool {
    return math.Abs(f1-f2) < p
}
```

## 复数类型

复数由两个浮点数构成，一个表示实部`real`，另一个表示虚部`imag`：

```go
var valueComplex complex64  // 由2个float32构成的复数

valueComplex = 3.2 + 12i
valueComlex2 := 3.2 + 12i         // valueComlex2是complex128类型
valueComlex3 := complex(3.2, 12)  // valueComlex3是complex128类型
```

